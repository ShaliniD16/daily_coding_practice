Reverse a Linked List in Groups

Given a linked list, the task is to reverse every k node (where k is an input to the function) in the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should be considered as a group and must be reversed (See Example 2 for clarification).

Examples:

Input: Linked List: 1->2->2->4->5->6->7->8, k = 4
Output: 4 -> 2 -> 2 -> 1 -> 8 -> 7 -> 6 -> 5 

Explanation: The first 4 elements 1,2,2,4 are reversed first and then the next 4 elements 5,6,7,8. Hence, the resultant linked list is 4->2->2->1->8->7->6->5.
Input: LinkedList: 1->2->3->4->5, k = 3
Output: 3 -> 2 -> 1 -> 5 -> 4

Explanation: The first 3 elements 1,2,3 are reversed first and then element 4,5 are reversed. Hence, the resultant linked list is 3->2->1->5->4.
Expected Time Complexity: O(n)
Expected Space Complexity: O(1)

Constraints:
1 <= size of linked list <= 106
1 <= data of nodes <= 106
1 <= k <= size of linked list 

class Solution {
    public static Node reverse(Node node, int k) {
        
        // Your code here
        Node curr = node,prv = null,next=null;
        int count = 0;
       
        while(curr!=null && count<k){
            
            
                next = curr.next;
                curr.next = prv;
                prv = curr;
                curr = next;
                count++;
            
            
            
        }
        if(next!=null){
            node.next = reverse(next,k);
        }
        return prv;
        
    }
}